{document}
% Knapsack report — cleaned and consistent
% Knapsack report — cleaned and consistent
\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{verbatim}
\begin{document}

% Mapeamento das implementações (colocado no início a pedido do autor)
\section*{Mapeamento de arquivos}
Para clareza, as implementações no repositório estão nomeadas como:
\begin{itemize}
  \item \texttt{1\_brutalF.py}: implementação ingênua (força bruta recursiva);
  \item \texttt{2\_pd.py}: implementação memoizada (top-down);
  \item \texttt{3\_greed.py}: heurística gulosa (razão valor/peso);
  \item \texttt{4\_pd\_com\_itens.py}: implementação por PD que reconstrói os itens.
\end{itemize}

\section*{Seção 2 — Código de exemplo, resultados e estimativas}

\subsection*{Exemplo: código de \texttt{1\_brutalF.py} (implementação ingênua recursiva)}
O código a seguir é a implementação ingênua recursiva usada como \texttt{1\_brutalF.py}: 
\begin{verbatim}
#[Naive Approach] Using Recursion O(2^n) Time and O(n) Space
# Returns the maximum value that
# can be put in a knapsack of capacity W
def knapsackRec(W, val, wt, n):

  # Base Case
  if n == 0 or W == 0:
    return 0

  pick = 0

  # Pick nth item if it does not exceed the capacity of knapsack
  if wt[n - 1] <= W:
    pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1)
    
  # Don't pick the nth item
  notPick = knapsackRec(W, val, wt, n - 1)
     
  return max(pick, notPick)

def knapsack(W, val, wt):
  n = len(val)
  return knapsackRec(W, val, wt, n)

if __name__ == "__main__":
  val = [1, 2, 3]
  wt = [4, 5, 1]
  W = 4

  print(knapsack(W, val, wt))
\end{verbatim}

\begin{figure}[h]
\centering
\includegraphics[width=0.75\textwidth]{figs/impl1_times.png}
\caption{Tempos medidos (escala log) para a implementação ingênua em função de $n$.}
\label{fig:impl1_times}
\end{figure}

\subsection*{Maior problema com solução ótima obtida}
Experimentalmente, a maior instância para a qual foi obtida a solução ótima por uma implementação prática foi:

- Versão otimizada (arquivo \texttt{4\_pd\_com\_itens.py}): $n = 32$, capacidade $W = 100$, tempo medido $T(32) \approx 9.995\\times10^{-4}\,$s (registro em \texttt{results.csv}).

Observação: a solução ótima para $n=32$ foi obtida pela implementação em \texttt{4\_pd\_com\_itens.py}. A implementação ingênua (arquivo \texttt{1\_brutalF.py}) apresenta tempos aceitáveis apenas para instâncias menores; nos dados experimentais os tempos tornam-se proibitivos acima de $n\approx 20$ (registros de timeout para $n=28,30,32$ em algumas execuções).

\subsection*{Comentário sobre a limitação}
O comportamento observado é consistente com a análise teórica:
- A implementação ingênua (arquivo \texttt{1\_brutalF.py}) tem complexidade temporal $\\Theta(2^{n})$ — o número de chamadas recursivas cresce exponencialmente.
- A implementação por programação dinâmica (arquivo \texttt{4\_pd\_com\_itens.py}) tem custo polinomial dependente de $n$ e da capacidade $W$, resultando em tempos muito menores na prática quando $W$ é moderado.

Na prática, cada incremento em $n$ tende a multiplicar o tempo por fator próximo de 2 na versão ingênua, daí o crescimento exponencial observado.

\subsection*{Estimativa para entrada 10\\times maior que o maior problema resolvido}
Vamos estimar o tempo necessário para uma entrada $10\\times$ maior que o maior problema resolvido experimentalmente ($n_{max}=32$). Mostramos duas estimativas: para a implementação exata (arquivo \texttt{4\_pd\_com\_itens.py}) e para a implementação ingênua (arquivo \texttt{1\_brutalF.py}) usando o ajuste exponencial obtido dos dados.

\paragraph{1) Implementação exata (hipótese A: $W$ fixo)}
Se a capacidade $W$ permanece aproximadamente a mesma, o tempo da implementação baseada em PD cresce aproximadamente proporcional a $n$. Assim, para $n' = 10\\times 32 = 320$:
\[ T(320) \approx T(32) \cdot \frac{320}{32} \approx 9.995\\times10^{-4} \times 10 \approx 9.995\\times10^{-3}\ \text{s} \approx 0.01\ \text{s}.\]

\paragraph{2) Implementação exata (hipótese B: $W$ cresce 10\\times)}
Se tanto $n$ quanto $W$ aumentarem por $10\\times$, o custo que depende do produto $nW$ sugere um fator $100$ no tempo:
\[ T(320,W'=10W) \approx 100 \\times T(32) \approx 100 \\times 9.995\\times10^{-4} \approx 9.995\\times10^{-2}\ \text{s} \approx 0.10\ \text{s}.\]

\paragraph{3) Implementação ingênua — extrapolação exponencial}
Ajustando um modelo exponencial $T(n) \approx a \cdot b^{n}$ aos tempos medidos para a implementação ingênua obteve-se (regressão linear em $\ln T$):
\[ a \approx 4.9621\\times10^{-7},\\qquad b \approx 1.99023.\]
Usando esse modelo para $n' = 320$ (10\\times 32) resulta em:
\[ T_{naive}(320) \approx a \cdot b^{320} \approx 2.211\\times10^{89}\ \text{segundos} \approx 7.01\\times10^{81}\ \text{anos}.
\]

Conclusão: a extrapolação confirma que a versão ingênua é impraticável para escalas muito maiores — a implementação por PD se mantém viável sob hipóteses razoáveis sobre $W$.

% -------------------------
\section{Seção 3 — Implementação \texttt{4\_pd\_com\_itens.py} e referência}
\subsection*{Enunciado}
A solução por programação dinâmica deve retornar não apenas o valor ótimo, mas também os índices dos itens selecionados. A implementação apresentada abaixo reconstrói esses itens.

\subsection*{Código da implementação (arquivo \texttt{4\_pd\_com\_itens.py})}
O código abaixo implementa a tabela de PD e a reconstrução dos itens selecionados (trecho):
\begin{verbatim}
"""  
Dynamic programming 0/1 knapsack with item reconstruction.

Provides two functions:
- `knapsack(W, val, wt)` -> returns maximum total value (int)
- `knapsack_with_items(W, val, wt)` -> returns (total_value, chosen_indices)
"""
def knapsack_with_items(W, val, wt):
  """
  Bottom-up DP for 0/1 knapsack that also reconstructs the chosen items.
  Returns (max_value, chosen_indices) where chosen_indices is a list
  of 0-based item indices.
  """
  n = len(val)
  dp = [[0] * (W + 1) for _ in range(n + 1)]

  for i in range(1, n + 1):
    vi = val[i - 1]
    wi = wt[i - 1]
    for w in range(0, W + 1):
      if wi <= w:
        pick = vi + dp[i - 1][w - wi]
        not_pick = dp[i - 1][w]
        dp[i][w] = max(pick, not_pick)
      else:
        dp[i][w] = dp[i - 1][w]

  chosen = []
  w = W
  for i in range(n, 0, -1):
    if dp[i][w] != dp[i - 1][w]:
      chosen.append(i - 1)
      w -= wt[i - 1]
      if w <= 0:
        break

  chosen.reverse()
  return dp[n][W], chosen
\end{verbatim}

\subsection*{Origem e referência}
Material de apoio consultado: W3Schools — "Knapsack Problem" (\url{https://www.w3schools.com/dsa/dsa_ref_knapsack.php}).

\subsection*{Imagem ilustrativa}
\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figs/tabela.png}
\caption{Exemplo de tabela de DP utilizada no tutorial (fonte: W3Schools).}
\label{fig:tabela_w3}
\end{figure}

\section{Seção 4 — Algoritmo aproximado (arquivo \texttt{3\_greed.py})}
\subsection*{Descrição}
Usamos uma heurística gulosa baseada na razão valor/peso. Ordena-se os itens por $v/w$ decrescente e seleciona-se enquanto houver capacidade. Complexidade: $O(n\log n)$ pela ordenação.

\subsection*{Código (arquivo \texttt{3\_greed.py})}
\begin{verbatim}
#[Approximation] Greedy approach (value/weight ratio) - O(n log n) time
def knapsack(W, val, wt):
  """
  Greedy approximation for 0/1 knapsack: sort items by value/weight
  ratio and pick while capacity allows.
  """
  n = len(val)
  items = []
  for i in range(n):
    if wt[i] <= 0:
      ratio = float('inf')
    else:
      ratio = val[i] / wt[i]
    items.append((ratio, wt[i], val[i], i))

  items.sort(key=lambda x: x[0], reverse=True)

  remaining = W
  total_value = 0
  for ratio, w, v, idx in items:
    if w <= remaining:
      remaining -= w
      total_value += v
    if remaining == 0:
      break

  return total_value
\end{verbatim}

\section{Seção 5 — Análise de complexidade}
\subsection*{Algoritmo 1 — \texttt{1\_brutalF.py} (ingênuo recursivo)}
- Tempo: $\Theta(2^{n})$ no pior caso.
- Espaço: $O(n)$ (profundidade da pilha de chamadas).

\subsection*{Algoritmo 2 — \texttt{2\_pd.py} (memoizado / top-down)}
- Tempo: $O(nW)$.
- Espaço: $O(nW)$.

\subsection*{Algoritmo 3 — \texttt{3\_greed.py} (heurística gulosa)}
- Tempo: $O(n\log n)$.
- Espaço: $O(n)$.

Resumo comparativo: heurística gulosa ($O(n\log n)$) \ll memoização/PD ($O(nW)$, se $W$ moderado) \ll força bruta recursiva ($\Theta(2^{n})$).
% Knapsack report — cleaned and consistent
\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{verbatim}
\begin{document}

% Mapeamento das implementações (colocado no início a pedido do autor)
\section*{Mapeamento de arquivos}
Para clareza, as implementações no repositório estão nomeadas como:
\begin{itemize}
  \item \texttt{1\_brutalF.py}: implementação ingênua (força bruta recursiva);
  \item \texttt{2\_pd.py}: implementação memoizada (top-down);
  \item \texttt{3\_greed.py}: heurística gulosa (razão valor/peso);
  \item \texttt{4\_pd\_com\_itens.py}: implementação por PD que reconstrói os itens.
\end{itemize}

\section*{Seção 2 — Código de exemplo, resultados e estimativas}

\subsection*{Exemplo: código de \texttt{1\_brutalF.py} (implementação ingênua recursiva)}
O código a seguir é a implementação ingênua recursiva usada como \texttt{1\_brutalF.py}: 
\begin{verbatim}
#[Naive Approach] Using Recursion O(2^n) Time and O(n) Space
# Returns the maximum value that
# can be put in a knapsack of capacity W
def knapsackRec(W, val, wt, n):

  # Base Case
  if n == 0 or W == 0:
    return 0

  pick = 0

  # Pick nth item if it does not exceed the capacity of knapsack
  if wt[n - 1] <= W:
    pick = val[n - 1] + knapsackRec(W - wt[n - 1], val, wt, n - 1)
    
  # Don't pick the nth item
  notPick = knapsackRec(W, val, wt, n - 1)
     
  return max(pick, notPick)

def knapsack(W, val, wt):
  n = len(val)
  return knapsackRec(W, val, wt, n)

if __name__ == "__main__":
  val = [1, 2, 3]
  wt = [4, 5, 1]
  W = 4

  print(knapsack(W, val, wt))
\end{verbatim}

\begin{figure}[h]
\centering
\includegraphics[width=0.75\textwidth]{figs/impl1_times.png}
\caption{Tempos medidos (escala log) para a implementação ingênua em função de $n$.}
\label{fig:impl1_times}
\end{figure}

\subsection*{Maior problema com solução ótima obtida}
Experimentalmente, a maior instância para a qual foi obtida a solução ótima por uma implementação prática foi:

- Versão otimizada (arquivo \texttt{4\_pd\_com\_itens.py}): $n = 32$, capacidade $W = 100$, tempo medido $T(32) \approx 9.995\\times10^{-4}\,$s (registro em \texttt{results.csv}).

Observação: a solução ótima para $n=32$ foi obtida pela implementação em \texttt{4\_pd\_com\_itens.py}. A implementação ingênua (arquivo \texttt{1\_brutalF.py}) apresenta tempos aceitáveis apenas para instâncias menores; nos dados experimentais os tempos tornam-se proibitivos acima de $n\approx 20$ (registros de timeout para $n=28,30,32$ em algumas execuções).

\subsection*{Comentário sobre a limitação}
O comportamento observado é consistente com a análise teórica:
- A implementação ingênua (arquivo \texttt{1\_brutalF.py}) tem complexidade temporal $\\Theta(2^{n})$ — o número de chamadas recursivas cresce exponencialmente.
- A implementação por programação dinâmica (arquivo \texttt{4\_pd\_com\_itens.py}) tem custo polinomial dependente de $n$ e da capacidade $W$, resultando em tempos muito menores na prática quando $W$ é moderado.

Na prática, cada incremento em $n$ tende a multiplicar o tempo por fator próximo de 2 na versão ingênua, daí o crescimento exponencial observado.

\subsection*{Estimativa para entrada 10\\times maior que o maior problema resolvido}
Vamos estimar o tempo necessário para uma entrada $10\\times$ maior que o maior problema resolvido experimentalmente ($n_{max}=32$). Mostramos duas estimativas: para a implementação exata (arquivo \texttt{4\_pd\_com\_itens.py}) e para a implementação ingênua (arquivo \texttt{1\_brutalF.py}) usando o ajuste exponencial obtido dos dados.

\paragraph{1) Implementação exata (hipótese A: $W$ fixo)}
Se a capacidade $W$ permanece aproximadamente a mesma, o tempo da implementação baseada em PD cresce aproximadamente proporcional a $n$. Assim, para $n' = 10\\times 32 = 320$:
\[ T(320) \approx T(32) \cdot \frac{320}{32} \approx 9.995\\times10^{-4} \times 10 \approx 9.995\\times10^{-3}\ \text{s} \approx 0.01\ \text{s}.\]

\paragraph{2) Implementação exata (hipótese B: $W$ cresce 10\\times)}
Se tanto $n$ quanto $W$ aumentarem por $10\\times$, o custo que depende do produto $nW$ sugere um fator $100$ no tempo:
\[ T(320,W'=10W) \approx 100 \\times T(32) \approx 100 \\times 9.995\\times10^{-4} \approx 9.995\\times10^{-2}\ \text{s} \approx 0.10\ \text{s}.\]

\paragraph{3) Implementação ingênua — extrapolação exponencial}
Ajustando um modelo exponencial $T(n) \approx a \cdot b^{n}$ aos tempos medidos para a implementação ingênua obteve-se (regressão linear em $\ln T$):
\[ a \approx 4.9621\\times10^{-7},\\qquad b \approx 1.99023.\]
Usando esse modelo para $n' = 320$ (10\\times 32) resulta em:
\[ T_{naive}(320) \approx a \cdot b^{320} \approx 2.211\\times10^{89}\ \text{segundos} \approx 7.01\\times10^{81}\ \text{anos}.
\]

Conclusão: a extrapolação confirma que a versão ingênua é impraticável para escalas muito maiores — a implementação por PD se mantém viável sob hipóteses razoáveis sobre $W$.

% -------------------------
\section{Seção 3 — Implementação \texttt{4\_pd\_com\_itens.py} e referência}
\subsection*{Enunciado}
A solução por programação dinâmica deve retornar não apenas o valor ótimo, mas também os índices dos itens selecionados. A implementação apresentada abaixo reconstrói esses itens.

\subsection*{Código da implementação (arquivo \texttt{4\_pd\_com\_itens.py})}
O código abaixo implementa a tabela de PD e a reconstrução dos itens selecionados (trecho):
\begin{verbatim}
"""  
Dynamic programming 0/1 knapsack with item reconstruction.

Provides two functions:
- `knapsack(W, val, wt)` -> returns maximum total value (int)
- `knapsack_with_items(W, val, wt)` -> returns (total_value, chosen_indices)
"""
def knapsack_with_items(W, val, wt):
  """
  Bottom-up DP for 0/1 knapsack that also reconstructs the chosen items.
  Returns (max_value, chosen_indices) where chosen_indices is a list
  of 0-based item indices.
  """
  n = len(val)
  dp = [[0] * (W + 1) for _ in range(n + 1)]

  for i in range(1, n + 1):
    vi = val[i - 1]
    wi = wt[i - 1]
    for w in range(0, W + 1):
      if wi <= w:
        pick = vi + dp[i - 1][w - wi]
        not_pick = dp[i - 1][w]
        dp[i][w] = max(pick, not_pick)
      else:
        dp[i][w] = dp[i - 1][w]

  chosen = []
  w = W
  for i in range(n, 0, -1):
    if dp[i][w] != dp[i - 1][w]:
      chosen.append(i - 1)
      w -= wt[i - 1]
      if w <= 0:
        break

  chosen.reverse()
  return dp[n][W], chosen
\end{verbatim}

\subsection*{Origem e referência}
Material de apoio consultado: W3Schools — "Knapsack Problem" (\url{https://www.w3schools.com/dsa/dsa_ref_knapsack.php}).

\subsection*{Imagem ilustrativa}
\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figs/tabela.png}
\caption{Exemplo de tabela de DP utilizada no tutorial (fonte: W3Schools).}
\label{fig:tabela_w3}
\end{figure}

\section{Seção 4 — Algoritmo aproximado (arquivo \texttt{3\_greed.py})}
\subsection*{Descrição}
Usamos uma heurística gulosa baseada na razão valor/peso. Ordena-se os itens por $v/w$ decrescente e seleciona-se enquanto houver capacidade. Complexidade: $O(n\log n)$ pela ordenação.

\subsection*{Código (arquivo \texttt{3\_greed.py})}
\begin{verbatim}
#[Approximation] Greedy approach (value/weight ratio) - O(n log n) time
def knapsack(W, val, wt):
  """
  Greedy approximation for 0/1 knapsack: sort items by value/weight
  ratio and pick while capacity allows.
  """
  n = len(val)
  items = []
  for i in range(n):
    if wt[i] <= 0:
      ratio = float('inf')
    else:
      ratio = val[i] / wt[i]
    items.append((ratio, wt[i], val[i], i))

  items.sort(key=lambda x: x[0], reverse=True)

  remaining = W
  total_value = 0
  for ratio, w, v, idx in items:
    if w <= remaining:
      remaining -= w
      total_value += v
    if remaining == 0:
      break

  return total_value
\end{verbatim}

\section{Seção 5 — Análise de complexidade}
\subsection*{Algoritmo 1 — \texttt{1\_brutalF.py} (ingênuo recursivo)}
- Tempo: $\Theta(2^{n})$ no pior caso.
- Espaço: $O(n)$ (profundidade da pilha de chamadas).

\subsection*{Algoritmo 2 — \texttt{2\_pd.py} (memoizado / top-down)}
- Tempo: $O(nW)$.
- Espaço: $O(nW)$.

\subsection*{Algoritmo 3 — \texttt{3\_greed.py} (heurística gulosa)}
- Tempo: $O(n\log n)$.
- Espaço: $O(n)$.

Resumo comparativo: heurística gulosa ($O(n\log n)$) \ll memoização/PD ($O(nW)$, se $W$ moderado) \ll força bruta recursiva ($\Theta(2^{n})$).